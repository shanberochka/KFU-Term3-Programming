#Ravesli 

Будем создавать простую игру, в которой вы будете сражаться с монстрами. Цель игры — собрать максимум золота, прежде чем вы умрете или достигнете 20 уровня.

Игра состоит из 3-х классов: Creature, Player и Monster. Player и Monster наследуют класс Creature.

1. Сначала создайте класс Creature со следующими членами:

   - имя (std::string);

   - символ (char);

   - количество здоровья (int);

   - количество урона, которое он наносит врагу во время атаки (int);

   - количество золота, которое он имеет (int).

> Создайте полный набор геттеров (по одному на каждую переменную-член класса). Добавьте еще три метода:

   - void reduceHealth(int), который уменьшает здоровье Creature на указанное целочисленное значение;

   - bool isDead(), который возвращает true, если здоровье Creature равно 0 или меньше;

   - void addGold(int), который добавляет золото Creature-у.
   
2. Теперь нам нужно создать класс Player, который наследует Creature. Player имеет:

   - переменную-член level, которая начинается с 1;

   - имя (пользователь вводит с клавиатуры);

   - символ @;

   - 10 очков здоровья;

   - 1 очко урона (для начала);

   - и 0 золота.

> Напишите метод levelUp(), который увеличивает уровень Player-а и его урон на 1. Также напишите геттер для члена level и метод hasWon(), который возвращает true, если Player достиг 20 уровня.

3. Следующий класс Monster также наследует Creature и у него нет собственных переменных-членов. Но есть перечисление Type, которое содержит 3 перечислителя, они обозначают типы монстров: DRAGON, ORC и SLIME (вам также нужен дополнительный перечислитель MAX_TYPES).
4. Каждый тип Монстра имеет свое имя, символ, определенное количество здоровья, урона и золота:
> Следующий шаг — реализация конструктора класса Monster, с помощью которого можно создавать монстров. Этот конструктор должен принимать перечисление Type в качестве параметра, а затем создавать монстра с соответствующими таблице характеристиками.

Это можно реализовать по-разному. Однако, поскольку все наши свойства типов монстров предопределены (не случайны), то мы будем использовать таблицу поиска. Таблица поиска — это массив, который содержит все предопределенные атрибуты (свойства) чего-либо. Мы можем использовать таблицу поиска для просмотра характеристики определенного типа монстра по мере необходимости.

Как это сделать? Нам нужны всего лишь две вещи. Во-первых, массив с отдельным элементом для каждого типа монстра. Во-вторых, этот элемент будет содержать структуру, в которой будут находиться все предопределенные значения атрибутов для конкретного типа монстра.

   - Шаг №1: Создайте структуру MonsterData внутри класса Monster. Эта структура должна иметь следующие перечислители: name, symbol, health, damage и gold.

   - Шаг №2: Объявите статический массив этой структуры с именем monsterData.

   - Шаг №3: Добавьте код определения нашей таблицы поиска вне тела класса:
   
  5. Наконец, добавьте статический метод getRandomMonster() в класс Monster. Этот метод должен генерировать случайное число от 0 до MAX_TYPES-1 и возвращать (возврат по значению) определенный тип монстра (вам нужно использовать оператор static_cast для конвертации int в Type, чтобы передать его конструктору класса Monster).
  6. Готово, теперь нам нужно разобраться с логикой выполнения нашей игры!

Суть:

   - Игрок сталкивается с одним случайно выбранным монстром.

   - С каждым монстром игрок может либо (R)un, либо (F)ight.

   - Если игрок решает Run, то шансы на удачный побег составляют 50%.

   - Если игроку удается сбежать, то ​​он благополучно переходит к следующему монстру (его здоровье/урон/золото при этом не уменьшается).

   - Если игроку не удается сбежать, то монстр его атакует. Здоровье игрока уменьшается от урона монстра. Затем игрок выбирает свое следующее действие.

   - Если игрок выбирает Fight, то он атакует монстра. Здоровье монстра уменьшается от урона игрока.

   - Если монстр умирает, то игрок забирает всё золото монстра + увеличивает свой level и урон на 1.

   - Если монстр не умирает, то он атакует игрока. Здоровье игрока уменьшается от урона монстра.

   - Игра заканчивается, если игрок умер (проигрыш) или достиг 20 уровня (выигрыш).

   - Если игрок умирает, то программа должна сообщить игроку, какой уровень у него был и сколько золота он имел.

   - Если игрок побеждает, то игра должна сообщить игроку, что он выиграл и сколько у него есть золота.

Пример игры:
> Enter your name: Anton
> Welcome, Anton
> You have encountered a orc (o).
> (R)un or (F)ight: r
> You successfully fled.
> You have encountered a slime (s).
> (R)un or (F)ight: f
> You hit the slime for 1 damage.
> You killed the slime.
> You are now level 2.
> You found 10 gold.
> You have encountered a dragon (D).
> (R)un or (F)ight: f
> You hit the dragon for 2 damage.
> The dragon hit you for 4 damage.
(R)un or (F)ight: f
> You hit the dragon for 2 damage.
> The dragon hit you for 4 damage.
> (R)un or (F)ight: f
> You hit the dragon for 2 damage.
> The dragon hit you for 4 damage.
> You died at level 2 and with 10 gold.
> Too bad you can't take it with you!

Подсказка: У вас должны быть следующие 4 функции:

   - Функция создания Игрока и основной игровой цикл (в функции main()).

   - Функция fightMonster(), которая обрабатывает бой между Игроком и Монстром, и спрашивает у игрока, что он хочет сделать: Run или Fight.

   - Функция attackMonster(), которая обрабатывает атаку монстра игроком, включая увеличение уровня игрока.

   - Функция attackPlayer(), которая обрабатывает атаку игрока монстром.
